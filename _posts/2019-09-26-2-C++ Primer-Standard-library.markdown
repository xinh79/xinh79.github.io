---
layout:      post
title:       "读书笔记：《C++ Primer Ver5》-II"
subtitle:    "C++ Primer Standard-library"
author:      "Ashior"
header-img:  "img/ReadNotes/bg-C++ Primer.jpg"
catalog:     true
tags:
  - 工作
  - C++
  - 读书笔记
---

> 其中对标准库中的方法介绍并没有详细给出，具体请参考http://www.cplusplus.com/

> 您也可以持续关注本主页，后续笔者还会上传关于《STL源码剖析》书籍的读书笔记。

## IO类

#### 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如：

```cpp
os << "please input a value: ";
```

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后打印出来。由于设备的写操作可能很耗时，允许操作系统将多个操作组合为单一的系统级写操作。

**导致缓冲区刷新的原因：**

1. 程序正常结束，作为`main`函数的`return`操作的一部分，缓冲区刷新被执行
2. 缓冲区写满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区
3. 我们可以使用操纵符如endl来显示刷新缓冲区
4. 在每个输出操作之后，使用操纵符`unitbuf`设置流的内部状态，来清空缓冲区。默认情况下，对`cerr`是设置`unitbuf`的，因此写入到`cerr`的内容都是立即刷新的。
5. 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。

`flush`刷新缓冲区，但不会输出任何额外的字符；`ends`向缓冲区插入一个空字符，然后刷新缓冲区;

```cpp
cout << "hello" << flush;
```

如果程序异常终止，输出缓冲区是不会被刷新的。`unitbuf`操纵符使在接下来的每一次写操作之后都进行一次flush操作。而`nounitbuf`操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。

#### 文件输入输出

头文件**fstream**定义了三种类型支持文件IO操作：`ifstream`从一个给定文件读取数据；`ofstream`向一个给定文件中写入数据；`fstream`可以读写给定文件。

## string流

`sstream`头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。

`istringstream`从string读取数据，`ostringstream`向string写入数据，而头文件`stringstream`既可以送string读取数据，也可以从string写入数据。

----

## 顺序容器

C++11中新增`forward_list`和`array`。与内置数组类似，`array`对象的大小是固定的。因此array不支持添加和删除元素以及改变容器大小的操作。`forward_list`的设计目标是达到与最好的手写的单向链表数据结构相当的性能。

当不需要写访问时，应使用`cbegin`和`cend`。

`swap`：处`array`外，交换两个容器内容的操作保证会很快——元素本身并未交换，`swap`只是交换了两个容器的**内部结构**。除`array`外，`swap`不对任何元素进行**拷贝**、**删除**或**插入**操作，因此可以保证在常数时间内完成。

向`vector`或`string`中添加一个元素，可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。

**容器元素的拷贝**中，放入到容器中的是对象值得一个拷贝，而不是对象本身。

对一个容器调用`front`和`back`，就像使用一个越界的下标一样，是一种严重的程序设计错误。

#### 迭代器失效

删除`deque`中首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向`vector`或`string`中删除点之后位置的迭代器、引用和指针都会失效。

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效、

向容器添加元素后：

1. 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间没有被重新分配，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
2. 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
3. 对于`list`和`forward_list`，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。

当我们从容器中删除一个元素后，指向被删除元素的迭代器、指针和引用会失效。

1. 对于`list`和`forward_list`，指向容器其它位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍然有效。
2. 对于`deque`，如果在尾首之外的任何位置删除元素，那么指向被删除元素外其它元素的迭代器、引用或指针也会失效。如果使删除`deque`的尾元素，则尾后迭代器会失效，但其它迭代器。引用和指针不受影响。如果使删除首元素，这些也不受影响。
3. 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍然有效。注意：当我们删除元素时，尾后迭代器总是会失效。

#### vector增长

`vector`的元素必须是连续存储。容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。

----

## 泛型算法

#### 只读算法

`find`，`accumulate`，`equal`属于只读算法。

```cpp
// 对vec中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```

这条语句将sum设置为vec中元素的和，和的初值被设置为0。当然`accumulate`还可以用来字符串连接。下面一个例子由于`string`定义了`+`运算符，所以我们可以通过调用`accumulate`来将vector中所有的`string`元素连接起来：

```cpp
string sum = accumulate(v.cbegin(), v.cend(), string(""));
// 错误：const char*上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```

第二条语句传递了一个字符串字面值，用于保存和的对象的类型将是`const char*`。由于`const char*`没有`+`运算符，所以产生编译错误。

#### 写容器算法

`fill`属于写容器算法。

```cpp
// 将每个元素重置为0
fill(vec.begin(), vec.end(), 0);
// 将容器的一个字序列设置为10
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
```

#### 排序容器算法

`sort`，`unique`会重新排序容器，它是利用`<`运算符来实现排序的。

`unique`将相邻的重复项"消除"，并返回一个**指向不重复范围末尾的迭代器**。也就是`vector`的实际大小并没有改变，它仍然有之前的元素个数，。但是这些元素的顺序改变了，并且将重复的元素放在末尾迭代器之后。

**标准库算法是对迭代器，而非容器进行操作。因此，算法不能(直接)添加或删除元素。**

#### 算法定制操作

```cpp
// 比较函数，用来按照长度排序单词
bool isShorter(const string &s1, const string &s2) {
	return s1.size() < s2.size();
}
// 按照长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
```

#### lambda

一个`lambda`表达式可以理解为一个未命名的内联函数。

----

## 关联容器

`set`，`map`均要求不重复的关键字，或者允许重复关键字(`multimap`，`multiset`)

一个`map`的`value_type`是一个`pair`，我们可以改变`pair`的值，但不能改变关键字成员的值。

```cpp
// 错误：关键字是const的
map_it->first = "new_key";
```

| 按关键字有序保存元素 | 描述 |
|:---:|:---:|
|map|关联数组，保存关键字-值对|
|set|关键字即值|
|multimap|关键字可重复的map|
|multiset|关键字可重复的set|
|无序集合| 描述 |
|unordered_map|用哈希函数组织的map|
|unordered_set|用哈希函数组织的set|
|unordered_multimap|关键字可重复的unordered_map|
|unordered_multiset|关键字可重复的unordered_set|


#### 无序容器

C++11定义了4个新的无序容器，这些容器不是使用比较运算符来组织元素，而是使用一个`哈希函数(hash function)`和关键字类型的`==`运算符。

无序容器使用一个哈希函数将元素映射到桶。无序容器的性能依赖于哈希函数的质量和桶的数量和大小。

----

## 动态内存

栈内存用来保存定义在函数内的`非static对象`。分配在`静态或栈内存`中的对象由编译器`自动创建和销毁`。对于栈对象，仅在其定义的程序块运行时才存在。

出了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作`自由空间`或`堆`。程序用堆来存储动态分配的对象。

#### 动态内存与智能指针

有时我们会忘记释放内存，这种情况下就会产生`内存泄漏`；有时，尚有指针引用内存的情况下，我们就释放了它，在这种情况下就会产生引用非法内存的指针。

C++11新标准库提供的这两种智能指针的区别在于`管理底层指针`的方式。`shared_ptr`允许多个指针指向同一个对象；`unique_ptr`则"独占"所指的对象。标准库中还定义了名为`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。这三种类型都定义在`memory`头文件中。

最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的`shared_ptr`。

当进行拷贝与赋值时，每个`shared_ptr`都会记录有多少个其它`shared_ptr`指向相同的对象。我们可以认为每个`shared_ptr`都有一个关联的计数器，通常称其为`引用计数器`。一旦一个`shared_ptr`的计数器变为0，它就会自动释放自己所管理的对象：

下面例子分配了一个`int`，将其指针保存在`r`中。接下来将一个新值赋予`r`。在这种情况下，`r`是唯一指向此`int`的`shared_ptr`，在把`q`赋值给`r`的过程中，此`int`被自动释放。

```cpp
auto r = make_shared<int>(42); // r指向的int只有一个引用者
r = q; 
// 给r赋值，令它指向另一个地址
// 递增q指向的对象的引用计数
// 递减r原来指向的对象的引用计数
// r原来指向的对象已没有引用者，会自动释放
```

关键是只能指针类能记录有多少个`shared_ptr`指向相同的对象，并能在恰当的时候自动释放对象。`shared_ptr`的西沟函数会递减它所指向的对象的引用计数。如果引用计数变为0.`shared_ptr`所西沟的函数就会销毁对象，并释放它占用的内存。

**使用动态内存的一个常见原因是袁旭多个对象共享相同的状态。**

希望`Blob`对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个`Blob`时，原`Blob`对象及其拷贝应该指引相同的底层元素。

```cpp
Blob<string> b1; // 空Blob
{	// 新的作用域
	Blob<tring> b2 = {"a", "b"};
	b1 = b2; // b1和b2共享相同的元素
	// b2被销毁了，但b2中的元素不能销毁
	// b1指向最初由b2创建的元素
}
```

`悬空指针`即指向一块曾经保存数据对象但现在已经无效的内存的指针。
