---
layout:      post
title:       "读书笔记：《C++ Primer Ver5》-III"
subtitle:    "C++ Primer Class-design-tool-and-other"
author:      "Ashior"
header-img:  "img/ReadNotes/bg-C++ Primer.jpg"
catalog:     true
tags:
  - 工作
  - C++
  - 读书笔记
---

> 再次申明，这里仅仅提供本人对《C++ Primer》书籍的部分记录。关于招聘所需要的内容，其实在不同的书籍中有不同的体现。而此书我将它通读，起导航引领作用。后面的东西很重要，分布在不同的书籍中，当然，如果就只想读这一本书，建议细读。

----

## 拷贝控制

#### 拷贝、赋值与销毁

一个类通常定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。西沟函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。

1. 需要析构函数的类也需要拷贝和赋值操作。
2. 一个类需要一个拷贝构造函数，同样需要一个拷贝赋值运算符。反之亦然。

我们可以通过拷贝控制成员定义为`=default`来显示地要求编译器生成合成的版本。

```cpp
// 拷贝控制成员；使用default
Sales_data() = dafault;
```

当我们在类内使用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联的(就像任何其他类内声明的成员函数一样)。我们只能对具有合成版本的成员函数使用`=default`(即，默认构造函数或拷贝控制成员)。
在函数的参数列表后面(与`=default`不同，`=delete`必须出现在函数第一次声明的时候)加上`=delete`来指出我们希望将它定义为删除的，也即`阻止拷贝`、`阻止赋值`。

```cpp
Sales_data(const Sales_data&) = delete; // 阻止拷贝
Sales_data &operator=(const Sales_data&) = delete; // 阻止赋值
```

本质上，当不能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。
在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为`private`的来阻止拷贝。

#### 拷贝控制和资源管理

C++11引入`右值引用`。其只能绑定到一个将要销毁的对象。因此我们可以自由地将一个右值引用的资源"移动"到另一个对象中。

```cpp
int i = 42;
int &r = i;       // 正确：r引用i
int &&rr = i;     // 错误：不能将右值引用绑定在左值上面
int &&rr2 = i*42; // 正确：将rr2绑定到乘法结果上
```

**左值持久；右值短暂**
：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于右值引用只能绑定到临时对象，我们得知，所引用的对象将要被销毁；该对象没有其他用户。

----

## 操作重载与类型转换

操作符重载样例：

```cpp
// 一个非成员运算符函数的等价调用
data1+data2;            // 普通的表达式
operator+(data1,data2); // 等价的函数调用
```

类类型转换样例：

```cpp
operator int() const { return this.value; }
SmallInt si;
// 首先将4隐式地转换成SmallInt，然后调用SmallInt::operator=
si = 4;
// 首先将si隐式地转换成int，然后执行整数的加法
si + 3;
// 调用SmallInt(int)构造函数
SmallInt si = 3.14;
// SmallInt的类型转换运算符将si转换成int
// 内置类型转换将所得的int继续转换成double
si + 3.14;
```

一个类类型转换函数必须是类的成员函数；他不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。

----

## 面向对象程序设计

面向对象程序设计的核心思想是数据抽象、继承和动态绑定。

C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字`final`。

不能继承友元关系；每个类负责控制各自成员的访问权限。

`struct`和`class`关键字定义的类具有不同的默认访问说明符。前者默认公有继承，后者默认私有继承，这也是他们唯一的区别。

```cpp
class Base;
struct D1 : Base {}  // 默认public继承
class D2 : Base {}   // 默认private继承
```

通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。

```cpp
class Quote {
public:
	// 如果我们删除的是一个指向派生类对象的基类指针，则需要需析构函数
	virtual ~Quote() = dafault; // 动态绑定析构函数
}
```

----

## 模板与泛型编程

函数模板以关键字`template`开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表。

```cpp
template <typename T>
int compare(const T &v1, const T &v2) {
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}
```

一个可变参数模板就是一个接受可变数据参数的模板函数或模板类。可变数目的参数被称为参数包。存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。


----

## 标准库特殊设施

#### tuple类型

`tuple`是类似于`pair`的模板。每个`pair`的成员类型都不同，但每个pair都恰好有两个成员。不同`tuple`类型的成员类型也不相同，但一个`tuple`可以由任意数量的成员。每个确定的`tuple`类型的成员数目是固定的，但一个`tuple`类型的成员数目可以与另一个`tuple`类型不同。

```cpp
tuple<string, vector<double>, int> someVal("value", {3.14, 2.1}, 1);>
```

`tuple`的这个构造函数是explicit的。我们也可以使用`make_tuple()`创建`tuple`类型。

#### 正则表达式

```cpp
// 查找不在字符c之后的字符串ei
string pattern("[^c]ei");
// 我们需要包含pattern的整个单词
pattern = "[[:alpha:]]*" + pattern + "*[[:alpha:]]";
// 构造一个用于查找模式的regex
regex r(pattern);
// 定义一个对象保存搜索结果
smatch results;
// 定义一个string保存于模式匹配和不匹配的文本
string test_str = "receipt freind theif receive";
// 用r在test_str中查找与pattern匹配的子串
// 如果有匹配字串
if (regex_search(test_str, results, r))
	cout << results.str() << endl;
```

#### 随机数

定义在头文件`random`中的随机数库通过一组协作的类来解决这些问题：**随机数引擎类**和**随机数分布类**。不应该使用库函数`rand`，而应该使用`default_random_engine`类和恰当的分布类对象。

```cpp
// 生成随机无符号数
default_random_engine e;
// e()调用对象来生成下一个随机数
for (size_t i = 0;)
```
----

## 大型程序工具

#### 异常处理

异常处理机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并作出相应的处理。同时可以挺过`noexcept`来说明指定某个函数不会抛出异常。

```cpp
void recoup(int) noexcept; // 不会抛出异常
void alloc(int);           // 可能抛出异常
```

`noexcept`有两层含义：当跟在函数参数列表后面时，它是异常说明符；而当作为`noexcept`异常说明的`bool`实参出现时，它是一个运算符。

#### 命名空间

多个库名字放置在全局命名空间中将引发**命名空间污染**。而**命名空间**可以防止名字冲突，提供了更加可控的机制。命名空间可以是不连续的，如果一个命名空间已经存在，则是再为其添加新成员的声明。

**未命名的命名空间**是指关键字`namespace`后面紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。

`using`声明存在风险，使用一条语句就使命名空间中所有成员的名字变得可见了。如果应用程序使用了多个不同的库，而这些库中的名字通过`using`指示变得可见，则全局命名空间污染的问题将重新出现。

#### 多重继承

多重继承是指从多个直接基类中产生派生类的能力。多重继承可能出现派生类从两个或多个基类中继承了同名成员的情况。不加前缀限定符直接使用改名字将引发二义性。(产生了潜在的二义性，不使用则不出现。。。)

----

## 特殊工具与技术

#### 控制和内存分配

当我们使用`new`时：第一步，`new`表达式调用一个名为`operator new/operator new[]`的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象。第二步编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。

当我们使用`delete`时：第一步，对其所指向的对象或者所指向的数组中的元素执行对应的析构函数。第二步，编译器调用名为`operator delete/operator delete[]`的标准库函数释放内存空间。

#### 运行时类型识别

运行时类型识别(run-time type identification, RTTI)的功能由两个运算符实现：`typeid`运算符，用于返回表达式的类型。`dynamic_cast`运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。
