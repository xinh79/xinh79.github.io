---
layout:      post
title:       "面试问题C++版-I"
subtitle:    "Job Interview - C++"
author:      "Ashior"
header-img:  "img/interview/bg-job-interview-cpp.jpg"
catalog:     true
tags:
  - 面试
  - C++
  - 工作
---

> 这个面试问题系列是对书本、网络上可能会被面试官询问的问题进行一个汇总，便于复习使用，这个汇总顺序为本人添加问题的时间顺序。注意，笔者给出的每一篇博客请仔细阅读，因为写的真的不错，也有相应的扩展。

侯捷的《EffectiveC++》书籍总结：[EffectiveC++](https://github.com/Making-It/note/blob/master/C++/EffectiveC++.md)， 时间紧迫的可以从此书入手。

[TOC]

----

#### 变量声明和定义区别

相同变量可以再多处声明（外部变量extern），但只能在一处定义。声明是告诉编译器变量的存在，在定义时才会分配存储空间。

#### explicit关键字

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外

参考博客：[explicit（显式）关键字](https://github.com/huihut/interview#explicit%E6%98%BE%E5%BC%8F%E5%85%B3%E9%94%AE%E5%AD%97)

#### nullptr和NULL的区别

这是因为由于C++的`NULL`就是一个字面值常量0，它是经过**预处理变量**来给指针赋值，所以传进去时，会被forward推断成`int &&`，`int &&`与`char *`当然不是一个东西，就会报错。

&&就是右值引用，&是普通的左值引用。个人认为右值引用的目的主要是为了是减少内存拷贝，优化性能。

**move**是将对象的状态或者所有权从一个对象转移到另一个对象，只是转义，没有内存拷贝。

**forward**将左值转换为右值。

参考博客：[C++11新特性之右值引用(&&)、移动语义(move)、完美转换(forward)](https://www.cnblogs.com/xiaobingqianrui/p/9064260.html) 、[c++11我理解的右值引用、移动语义和完美转发](https://www.jianshu.com/p/d19fc8447eaa)

#### strlen和sizeof区别

sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。**因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**

sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

#### 结构体内存对齐

- 第一个成员在与结构体偏移量为0的地址处。
- 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。VS中默认的对齐数为8，gcc中的对齐数为4
- 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
- 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

参考博客：[C++系列 15. C++结构体内存对齐规则](https://blog.csdn.net/yl_puyu/article/details/88817407)

#### 为什么要进行内存对齐

CPU每次访问4个字节，若没有对齐，获取的char或者int，需要进行字节切割及字节拼接，效率很低。内存对齐是一种空间换时间以提高效率的方式。

#### 什么是大小端

大端：高位存低地址。

小端：低位存低地址。

```
big endian:    0x11223344 -> |0x11|0x22|0x33|0x44|
little endian: 0x11223344 -> |0x44|0x33|0x22|0x11|
```

如何判断大小端：给一个int类型赋值为1，将其转为char类型，char类型仅占1个字节，若char类型结果为1的话，说明低地址存在低位，低地址存在高位为小端。反之char类型如果为0的话，为大端。

参考博客：[什么是大小端](https://blog.csdn.net/bobchill/article/details/86510819)

#### 结构体和类的区别？

结构体的默认限定符是public；类是private。

#### static的作用

static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量**存储位置在静态区**。

- 对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；
- 对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；
- 修饰函数时作用和修饰全局变量相同，都是为了限定访问域。

#### static在C和C++中有何区别

C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。

#### malloc和new的区别

- 【类型不同】malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。
- 【调用构造/析构】malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- 【返回类型】malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

#### 指针和引用区别

- 【存储空间】引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。
- 【初始化】引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。
- 【是否改变】引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。

#### 宏定义和函数有何区别

- 【编译方式】宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 【返回值】宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。

#### 宏定义和const区别

- 【编译】宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
- 【检查】宏不检查类型；const会检查数据类型。
- 【分配空间】宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

#### 宏定义和typedef区别

- 【编译】宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 【检查】宏不检查类型；typedef会检查数据类型。
- 【指针】注意对指针的操作，`typedef char * p_char`和`#define p_char char *`区别巨大。

#### 宏定义和内联函数(inline)区别

- 【编译】宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 【函数】内联函数本身是函数，强调函数特性，具有重载等功能。

#### 条件编译#ifdef, #else, #endif作用

- 【确定编译内容】可以通过加`#define`，并通过`#ifdef`来判断，将某些具体模块包括进要编译的内容。
- 【减少程序大小】条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。

#### 区分const的位置

```cpp
const int a;
int const a;
const int *a;
int *const a;
```

- `int const a`和`const int a`均表示定义常量类型a。
- `const int *a`，其中a为指向int型变量的指针，const在`*`左侧，表示a指向不可变常量。(看成`const (*a)`，对引用加const)，因此`*a`所指向的对象值不能通过`*a`来修改，但是可以重新给a来赋值，使其指向不同的对象。
- `int *const a`，依旧是指针类型，const在`*`右侧，表示a为指向整型数据的常指针，(看成const(a)，对指针const)。因此不能赋给a其他的地址值，但可以修改a指向的值。

#### volatile有什么作用

- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
- volatile告诉编译器不应对这样的对象进行优化。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

#### 什么是常引用

- 常引用可以理解为常量指针，常引用下，原变量值不会被别名所修改。
- 常引用通常用作只读变量别名或是形参传递。

#### 区别以下指针类型

```cpp
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- `int *p[10]`表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- `int *p(int)`是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

#### 常量指针和指针常量区别

- 常量指针是一个指针，读成常量的指针，指向一个只读变量。如`int const *p`或`const int *p`。
- 指针常量是一个不能给改变指向的指针。如`int *const p`。

#### a和&a有什么区别

```cpp
int a[10];
int (*p)[10] = &a;
```

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。`*(a + 1) = a[1]`。
- &a是数组的指针，其类型为`int (*)[10]`（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。

#### 数组名和指针（这里为指向数组首元素的指针）区别

当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

#### 野指针

也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。

产生原因及解决办法：

- 指针变量未及时初始化：定义指针变量及时初始化，要么置空。
- 指针free或delete之后没有及时置空：释放操作后立即置空。

#### 智能指针

- Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
- Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

**shared_ptr**

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁。

**weak_ptr**

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题。

**unique_ptr**

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

**auto_ptr 与 unique_ptr 比较**

- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
- auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用`delete[]`）；

参考博客：

[智能指针](https://blog.csdn.net/k346k346/article/details/81478223)

[C++ 智能指针详解](https://blog.csdn.net/xt_xiaotian/article/details/5714477)

#### 堆和栈的区别

- 【申请方式】栈由系统自动分配。堆由程序员手动分配。
- 【大小不同】栈顶和栈底是之前预设好的，大小固定，可以通过`ulimit -a`查看，由`ulimit -s`修改。堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 【分配速度】栈由系统分配，速度快，不会有碎片。堆由程序员分配，速度慢，且会有碎片。

#### delete和delete[]区别

- `delete`只会调用一次析构函数
- `delete[]`会调用数组中每个元素的析构函数

#### 内存泄露

一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

[内存溢出和内存泄露的区别与解决方案](https://bbs.csdn.net/topics/392721192)

#### 栈溢出

通常来说，一个线程的栈内存是有限的，通常来说是8M左右（取决于运行的环境）。栈上的内存通常是由编译器来自动管理的。由于栈上的内存的分配和回收都是由编译器控制的，所以在栈上是不会发生内存泄露的，只会发生**栈溢出（Stack Overflow）**，也就是分配的空间超过了规定的栈大小。

#### 字符串分配

为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向**相同的内存地址**。但用常量内存初始化数组，情况却有所不同。

```cpp
int main(){
    string s1 = "hello";
    string s2 = "hello";
    char * c1 = "hello";
    char * c2 = "hello";
    char v1[] = "hello";
    char v2[] = "hello";
	
	if (s1 == s2) {	cout << "s1 == s2" << endl;	}
	else { cout << "s1 != s2" << endl; }
	if (c1 == c2) {	cout << "c1 == c2" << endl; }
	else { cout << "c1 != c2" << endl; }
	if (v1 == v2) {	cout << "v1 == v2" << endl;	}
	else { cout << "v1 != v2" << endl; }
	return 0;
}
// 运行结果：
// s1 == s2
// c1 == c2
// v1 != v2
```

#### 面向对象三大特性

封装性、继承性、多态性（重载实现编译时多态，虚函数实现运行时多态）

#### 对象存储空间

- 非静态成员的数据类型大小之和。
- 编译器加入的额外成员变量（如指向虚函数表的指针）。
- 为了边缘对齐优化加入的padding。

#### C++空类有哪些成员函数

空类大小为1字节

默认函数有：构造函数、析构函数、拷贝构造函数、赋值运算符

#### 类的大小

1. 定义一个空的类型，里面啥也没有，sizeof后的大小为1，本来实际类型中不包含任何信息，但是声明该类型的时候必须占用一定空间，通常取决于编译器，通常大小为1。
2. 如果在类中添加构造函数与析构函数，依旧为1，因为调用这些函数只需要知道其地址即可，而这些函数只与类型相关，而与类型的实例无关，编译器也不会应该这两个函数的加入而对添加额外的信息。
3. 如果标记为虚函数，编译器就会生成虚函数表，并且向该类型的每个实例添加一个指向虚函数表的指针。**在32位的机器上，一个指针占用4字节的空间，64位的机器上，一个指针占用8字节的空间。**所以最后sizeof得到的大小为4/8。

#### 构造函数能否为虚函数，析构函数

析构函数：

- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
- 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
- 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

构造函数：

- 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。

#### 构造函数和析构函数调用时机

- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。
- 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。
- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

#### 虚函数和纯虚函数区别

- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。**虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。**当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

#### 拷贝构造函数

拷贝构造函数是一种**特殊的构造函数**，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个**引用变量**。如果自定义的拷贝构造函数不是传入引用变量，则会无休止的递归调用，最终导致**栈溢出**。

**当函数的参数为类的对象时**

```cpp
CppExample(const CppExample & c) {
	a=c.a;
}
void g_fun(CExample c);
```

调用g_fun()函数。

1. A对象传入形参时，会先会产生一个临时变量，就叫C吧。
2. 然后调用拷贝构造函数把A的值给C。整个这两个步骤有点像：CExample C(A);
3. 等g_fun()执行完后, 析构掉C对象

**函数的返回值是类的对象**

```cpp
CExample g_fun() {
    CExample temp(0);
    return temp;
}
```

当g_Fun()函数执行到return时，会产生以下几个重要步骤：

1. 先会产生一个临时变量，就叫XXXX吧。
2. 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);
3. 在函数执行到最后先析构temp局部变量。
4. 等g_fun()执行完后再析构掉XXXX对象。

```cpp
ST st1 = st; //此处调用了拷贝构造函数
ST st2(st);  //此处调用了拷贝构造函数
ST st3;
st3 = st;    //此处调用的是赋值语句
```
拷贝构造函数在三种情况下会被使用

1. 使用对象来初始化对象时
2. 当函数的形参是对象时
3. 当函数的返回值为对象时

拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。

**浅拷贝：**存在默认的拷贝构造函数：

**深拷贝：**对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间。

当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但**当数据成员中有指针时**，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致**指针悬挂现象**。所以必须采用深拷贝。

深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。**简而言之，当数据成员中有指针时，必须要用深拷贝。**

**【问题】**

- 为什么拷贝构造函数必须是引用传递，不能是值传递？

为了防止递归引用。

- 拷贝构造函数的作用。

作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。

- 参数传递过程到底发生了什么？

**值传递：**对于内置数据类型的传递时，直接赋值拷贝给形参。对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)。

**引用传递：**无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值。而地址总是指针类型(属于简单类型)。

- 拷贝构造函数里能调用private成员变量吗？

拷贝构造函数其实就是一个特殊的构造函数，操作的还是自己类的成员变量，所以不受private的限制。

- 构造函数能否重载，析构函数能否重载？

构造函数可以，析构函数不可以。

- 析构函数为什么一般情况下要声明为虚函数？

**虚函数是实现多态的基础**，当我们通过基类的指针是析构子类对象时候，如果不定义成虚函数，那只调用基类的析构函数，子类的析构函数将不会被调用。如果定义为虚函数，则子类父类的析构函数都会被调用。

- 什么情况下必须定义拷贝构造函数？

如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。如果定义了拷贝构造函数，那也必须重载赋值操作符。

参考博客：

[c++拷贝构造函数详解](https://www.cnblogs.com/alantu2018/p/8459250.html)

[拷贝构造函数和赋值函数](https://blog.csdn.net/gzj_1101/article/details/80521603)

#### 拷贝构造函数和赋值运算符重载的区别

- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

```cpp
Student s;
Student s1 = s;	// 调用拷贝构造函数
Student s2;
s2 = s;			// 赋值运算符操作
```

注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符

#### 覆盖、重载和隐藏的区别

- **覆盖是派生类中重新定义的函数**，其函数名、参数列表（个数、类型和顺序）、返回值类型**和父类完全相同，只有函数体有区别**。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。
- 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
- 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。

#### 使用初始化成员列表

- 初始化一个const、reference成员。
- 调用一个基类的构造函数，而该函数有一组参数。
- 调用一个数据成员对象的构造函数，而该函数有一组参数。

#### 虚指针

- 虚指针或虚函数指针是虚函数的实现细节。
- 虚指针指向虚表结构。
- 对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数

[虚指针、虚函数](https://blog.csdn.net/u012585868/article/details/88795526)

#### 虚函数

虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

参考博客：[c++虚函数详解](https://blog.csdn.net/haoel/article/details/1948051)

#### 重载和函数模板的区别

- 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。
- 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。

#### 类模板

- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。
- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。
- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。

#### this指针

- this指针是类的指针，指向对象的首地址。
- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

#### vector

- 线性表，数组实现。支持随机访问。插入删除操作需要大量移动数据。
- 需要连续的物理存储空间。
- 每当大小不够时，重新分配内存（*2），并复制原内容。

#### vector迭代器失效

插入元素：

- 尾后插入：`size < capacity`时，首迭代器不失效尾迭代失效（未重新分配空间），`size == capacity`时，所有迭代器均失效（需要重新分配空间）。
- 中间插入：`size < capacity`时，首迭代器不失效但插入元素之后所有迭代器失效，`size == capacity`时，所有迭代器均失效。

删除元素：

- 尾后删除：只有尾迭代失效。
- 中间删除：删除位置之后所有迭代失效。

[vector的迭代器失效](https://blog.csdn.net/lovehang99/article/details/88110582)

#### map

实现：

- 树状结构，RBTree实现。插入删除不需要数据复制。操作复杂度仅跟树高有关。
- RBTree本身也是二叉排序树的一种，key值有序，且唯一。必须保证key可排序。

基于红黑树实现的map结构（实际上是map，set，multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。

#### 红黑树

红黑树节点数据结构：

```cpp
enum Color {
    RED = 0,
    BLACK = 1
};
struct RBTreeNode {
    struct RBTreeNode*left, *right, *parent;
    int key;
    int data;
    Color color;
};
```

- 它是二叉排序树。若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。左、右子树也分别为二叉排序树。
- 树中所有节点非红即黑。
- 根节点必为黑节点。
- 红节点的子节点必为黑（黑节点子节点可为黑）。
- 从根到NULL的任何路径上黑结点数相同。
- 查找时间一定可以控制在O(logn)。

对红黑树的操作需要满足两点：

1. 满足二叉排序树的要求；
2. 满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。

相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。

从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列......最长路径不会大于2n，这里路径长就是树高。

#### 红黑树、B 树、B+ 树的区别

- 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些；
- B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起；

#### 编译及调试

预处理，编译，汇编，链接。

预处理：展开头文件/宏替换/去掉注释/条件编译；(test.i main .i)
编译：检查语法，生成汇编；(test.s  main .s)
汇编：汇编代码转换机器码；(test.o main.o)
链接：链接到一起生成可执行程序；(a.out)

**预处理：**

- 展开所有的宏定义，完成字符常量替换。
- 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。
- 处理#include指令，将被包含的文件插入到该指令所在位置。
- 过滤掉所有注释语句。
- 添加行号和文件名标识。
- 保留所有#pragma编译器指令。

**编译：**

检查语法。目标代码生成与优化。

**链接：**

各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。静态链接、动态链接。

**符号解析：**

可重定位目标文件。对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。

**解析符号表：**

解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。

**重定位：**

- 合并节：多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。
- 重定位符号引用：这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（"符号"）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。

**可执行目标文件：**

- ELF头部：描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。
- 段头部表：描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。
- 其他段：和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。

**加载：**

- 克隆：新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。
- 重新映射：当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。
- 虚页调入：加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作仅仅是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号+页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。

参考博客：[c语言编译过程详解，预处理，编译，汇编，链接(干货满满）](https://blog.csdn.net/weixin_41143631/article/details/81221777)
