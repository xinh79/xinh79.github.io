---
layout:      post
title:       "读书笔记：《C++ Primer Ver5》-I"
subtitle:    "C++ Primer Basic-knowledge"
author:      "Ashior"
header-img:  "img/ReadNotes/bg-C++ Primer.jpg"
catalog:     true
tags:
  - 工作
  - C++
  - 读书笔记
---

> 本节主要是介绍《C++ Primer 第五版》书中的第一部分：C++基础

----

# 变量和基本类型

## 基本内置类型

算数类型分为两种：整型(包括字符和布尔类型)和浮点型

|  类型  |  含义  | 最小尺寸 |
| :----: | :----: | :----: |
| char | 字符 | 8位 |
| short | 短整型 | 16位 |
| int | 整型 | 16位 |
| long | 长整型 | 32位 |
| long long | 长整型 | 64位 |
| float | 单精度浮点数 | 6位有效数字 |
| double | 双精度浮点数 | 10位有效数字 |
| long double | 拓展双精度浮点数 | 10位有效数字 |

long long 是在C++11中新定义的

**内置类型的机器实现：**
可寻址的最小内存块称为"字节(byte)"，存储的基本单元称为"字(word)"。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。

无符号类型(在类型名前添加`nsigned`)仅能表示大于等于0的值。与其他类型不同，字符型被分为三种：`char`、`signed char`、`unsigned char`。类型`char`实际上会表现为上述两种形式中的一种，具体是哪一种由编译器决定。无符号类型中所有比特都用来存储值，例如，8比特的`unsigned char`可以表示0-255区间内的值。当我们给无符号类型一个超过它表示范围的值时，结果是初始化对无符号类型表示总数取模后的余数，例如，我们对`unsigned` char赋予一个超出其范围的值，则实际的结果是该值对256取模后所得的余数，因此，把-1赋值给8比特大小的`unsigned char`所得的结果是255。

**带符号数会自动地转换成无符号数**

## 变量

**对象：**对象是指一块能存储数据并具有某种类型的内存空间。
**warning：**初始化不是赋值，初始化的含义是创建变量时赋予其中一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
C++11引入**列表初始化**，当使用列表初始化且**初始化值存在丢失信息的风险**，则编译器会报错。例如，将`long double`值赋值给`int`。

如果想要声明一个变量而非定义它，就在变量名前添加关键字`extern`，而不要显示地初始化变量。

```cpp
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```
**声明(declaration)**使得名字为程序所知，**定义(definition)**负责创建与名字关联的实体。

C++关键字有73个，操作符替代名11个。

## 复合类型

### 引用(reference)
引用必须被初始化，引用即别名，**引用并非对象，相反，他只是为一个已经存在的对象所起的另外一个名字。**这也解释了为什么不能定义引用的引用，因为引用本身不是对象。
**与指针的异同点：**指针是"指向"另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。但是也有不同的地方：
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内，他可以先后指向几个不同的对象。
2. 指针无需在定义时赋初值。和其他内置类型一样，这块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

得到空指针最直接的办法就是用**字面值nullptr**来初始化指针。

`void*`是一种特殊的指针类型，可用于存放任意对象的地址。利用`void*`指针能做的事有限：那他和别的指针比较、作为函数的输入或输出、或者赋给另外一个`void*`指针。我们不能直接操作`void*`，因为我们不知道这个对象到底是什么类型。

(以`void*`的视角来看内存空间就仅仅是内存空间，没办法访问内存空间中的对象)

## const限定符

默认状态下，const对象仅在文件内有效。编译器将在编译过程中把用到该变量的地方都替换成对应的值。有时候，为了在多个文件中声明并使用，对于const变量不管是声明还是定义都添加extern关键字。

**顶层const**表示指针本身是个常量，**底层const**表示指针所指的对象是一个常量。

```cpp
int *const p1 = &i //表示一个顶层const，不能改变p1的值
const int *p2 = &i //表示一个底层const，允许改变p2的值
```

**类型别名：**传统的方法是使用`typedef`，而在C++11中可以使用`using 别名 = 类型名;`

C++11中增加**auto类型**。auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```cpp
const int ci = i, &cr = ci;
auto b = ci;  // b是一个整数(ci的顶层const特性被忽略掉了)
auto c = cr;  // c是一个整数(cr是ci的别名，ci本身是一个顶层const)
auto d = &i;  // d是一个整型指针(整数的地址就是指向整数的指针)
auto e = &ci; // e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
```

C++11第二种引入的类型说明符是**decltype**，他的作用是选择并返回操作数的数据类型。decltype处理顶层const和引用的方式与auto有些不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)：
**注意：**decltype((variable))，注意是双层括号，此结果永远为引用。

```cpp
const int ci = i, &cj = ci;
decltype(ci) x = 0;  // x的类型是const int
decltype(cj) y = x;  // y的类型是const int&，y绑定到变量x
decltype(cj) z;      // 错误：z是一个引用，必须初始化
```

### 文件预处理概述
`#define`指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：`#ifdef`当且仅当变量已定义时为真，`#ifndef`当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作，知道遇到`#endif`指令为止。

----

# 字符串、向量和数组

## 标准库类型string

使用等号(=)初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，使用括号为直接初始化。
通常如果一条表达式中已经有了size()函数，就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。

```cpp
auto len = line.size(); // len的类型是string::size_type
```

## 标准库类型vector

vector是模板，而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。

如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。在范围for循环中预存了**end()**的值。一旦在序列中添加(删除)元素，**end()**函数的值就可能变得无效了。

## 迭代器介绍

无论vector对象(或string对象)本身是否是常量，返回值都是`const_iterator`。`(*it).empty()`，首先是对it进行解引用，然后解引用的结果再执行点运算符。

`iter1 - iter2`两个迭代器相减的结果是他们之间的距离。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。距离是指右侧迭代器向前移动多少位置就能追上左侧的迭代器，其类型名为`difference_type`的带符号整形数。因为这个距离可正可负。

**tips：**`auto mid = text.begin() + (end - beg)/2;`

## 数组

使用下标访问数组时，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型。

**缓冲区溢出错误：**当数组或其他类似数据结构的下标越界并试图访问非法内存区域时

`s.c_str()`返回是的一个C风格的字符串，即`const char *`。

----

# 表达式

## 算数运算符

**溢出：**当计算的结果超出该类型所能表示的范围时就会产生溢出。

`*p++`等价于`*(p++)`：后置递增运算符的优先级高于解引用运算符。p++把p的值加1，然后返回p的初始值的副本作为其求值结果，此时解引用运算符的对象是p为增加之前的对象。**后置递增运算符返回的未加1的值**

**位运算符**

|  运算符  |  功能  | 用法 |
| :----: | :----: | :----: |
| `~` | 位求反 | `~expr` |
| `<<` | 左移 | `expr1 << expr2` |
| `>>` | 右移 | `expr1 >> expr2` |
| `&` | 位与 | `expr1 & expr2` |
| `^` | 位移或 | `expr1 ^ expr2` |
| `|` | 位或 | `expr1 | expr2` |

----

# 函数

## return语句

不要返回局部对象的**引用或指针**

在C++11新标准规定，函数可以返回花括号包围的值得列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时变量进行初始化。

```cpp
vector<string> function() {
	return {"function", "okay"};
}
```

C++11提供**尾置返回类型**，通常用于返回类型是数组的指针或数组的引用。其实也可以使用decltype关键字。

```cpp
// func接受一个int类型的参数，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*)[10]
```

## 函数重载

当调用**重载函数**时有三种可能：
- 编译器找到一个与实参**最佳匹配(best match)**的函数，并生成调用该函数的代码。

- 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配(no match)**的错误信息。

- 有多余一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用(ambiguous call)**

可行函数有两个特征：

- 形参数量与本次调用提供的实参数量相等。

- 每个实参的类型与对应的形参类型相同，**或者可以转换成形参的类型**。

## 内联函数

**内联函数：**可以避免函数调用的开销，通常就是将他在每个调用点上"内联的"展开。内联说明只是向编译器发出请求，编译器也可以忽略这个请求。

**constexpr：**constexpr函数是指能用于常量表达式的函数。

```cpp
constexpr int new_sz() {return 7;}
constexpr int foo = new_ze(); // 正确：foo是一个常量表达式
```

## 函数指针

```cpp
// pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf) (const string &, const string &); // 未初始化
```

其中pf的小括号必不可少，不然会返回bool指针。

----

# 类

类的基本思想是**数据抽象**和**封装**。数据抽象是一中依赖于**接口**和**实现**分离的编程技术。

## 定义抽象数据类型

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

## 构造函数

构造函数的任务是初始化对象的数据成员。

不同于其他成员函数，构造函数不能被声明成const。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其"常量属性"。因此，构造函数在const对象的构造中可以向其写值。

只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。

某些类不能依赖于合成的默认构造函数：

1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。
2. 对于某些类，合成的默认构造函数可能执行错误的错误。(如果内置类型或复合类型(数组/指针)被初始化，则他们的值将是未定义的。)
3. 如果类中包含一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

在C++11中，使用`class_name() = default`可以保留合成默认构造函数。

如果编译器不支持类内初始化，那么应该在构造函数处使用构造函数初始值列表。他负责为新创建的一个或多个数据成员赋初值。

**warning：**使用class和struct定义类的唯一的区别就是默认的访问权限

**封装的益处：**
1. 确保用户代码不会无意间破坏封装对象的状态
2. 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码

**可变数据成员**

`mutable size_t access`

通过添加`mutable`关键字。一个可变数据成员永远不会是const，即便他是在const对象的成员。

在C++11中，最好的方式就是把这个默认值声明成一个类内初始值。

我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。

```cpp
class ConstRef {
	public:
		ConstRef(int i);
	private:
	int ii;
	const int ci;
	int &ri;
}
ConstRef::ConstRef(int i) : i(ii), ci(ii), ri(i) {}
```

如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

**初始化和赋值的区别**事关底层效率问题：前者直接初始化数据成员，后者则是先初始化再赋值。当然，除了效率问题，还有就是部分数据成员**必须被初始化**。

C++11定义了**委托构造函数**。使用它所属类的其他构造函数执行他自己的初始化过程，或者说他把他自己的一些(全部)职责委托给其他构造函数。

**explicit**构造函数只能用于直接初始化。它将只能以直接初始化的形式使用。而且编译器将不会在自动跳转过程中使用该构造函数。(通过在声明构造函数的时候添加explicit来阻止隐式转换)

**聚合类**

聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。需要满足以下条件：
1. 所有成员都是public的
2. 没有定义任何构造函数
3. 没有类内初始值
4. 没有基类，没有virtual函数

数据成员都是字面值类型的聚合类是**字面值常量类**。

